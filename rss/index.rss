<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"><channel><title>Ramblings of a Dude</title><description>Ramblings of a programmer, gamer, modder, maker and computer scientist</description><link>http://localhost:2368/</link><image><url>http://localhost:2368/favicon.png</url><title>Ramblings of a Dude</title><link>http://localhost:2368/</link></image><generator>Ghost 2.16</generator><lastBuildDate>Mon, 11 Mar 2019 17:42:39 GMT</lastBuildDate><atom:link href="http://localhost:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>Generating Chunks of Time Using Ruby</title><description>&lt;p&gt;The problem was iterating over a large amount of time series data. I figured generating a series of time chunks within certain start and end parameters, and of a certain time interval size could help scan through this data.&lt;/p&gt;&lt;p&gt;I wrote the following method to help generate these chunks of&lt;/p&gt;</description><link>http://localhost:2368/generating-chunks-of-time/</link><guid isPermaLink="false">5c869b73ce7e13044da9b82d</guid><category>Ruby_On_Rails</category><category>Programming</category><category>Ruby</category><dc:creator>Jason Chalom</dc:creator><pubDate>Mon, 11 Mar 2019 17:40:38 GMT</pubDate><media:content url="http://localhost:2368/content/images/2019/03/thedescent-1.png" medium="image"/><content:encoded>&lt;img src="http://localhost:2368/content/images/2019/03/thedescent-1.png" alt="Generating Chunks of Time Using Ruby"&gt;&lt;p&gt;The problem was iterating over a large amount of time series data. I figured generating a series of time chunks within certain start and end parameters, and of a certain time interval size could help scan through this data.&lt;/p&gt;&lt;p&gt;I wrote the following method to help generate these chunks of time which can then be passed to an ActiveRecord query to search within that time chunk for relevant data. &lt;/p&gt;&lt;!--kg-card-begin: html--&gt;&lt;script src="https://gist.github.com/TRex22/4ed5b18d883e41d8c6be1dc3a5a0a924.js"&gt;&lt;/script&gt;&lt;!--kg-card-end: html--&gt;&lt;p&gt;What is returned is an array of arrays where each internal array contains a start time and an end time which can then be used in further methods.&lt;/p&gt;&lt;p&gt;It escapes early if there is only one possible chunk for the given parameters. It also makes sure that the start time of the first interval is the given start parameter and the same is true for the end time of the last chunk.&lt;/p&gt;</content:encoded></item><item><title>Finding Non-Unique Elements in a Collection Using Ruby</title><description>Using hashes and counts to determine which elements in a collection is non-unique</description><link>http://localhost:2368/finding/</link><guid isPermaLink="false">5c84ddda9eb98298f4df03d6</guid><category>Ruby</category><category>Ruby_On_Rails</category><category>Programming</category><dc:creator>Jason Chalom</dc:creator><pubDate>Sun, 10 Mar 2019 10:49:21 GMT</pubDate><media:content url="http://localhost:2368/content/images/2019/03/theexpanse.png" medium="image"/><content:encoded>&lt;img src="http://localhost:2368/content/images/2019/03/theexpanse.png" alt="Finding Non-Unique Elements in a Collection Using Ruby"&gt;&lt;p&gt;This is a fairly simple problem but I keep finding myself looking this up and coming to a similar solution so I thought I would post this quick trick here. &lt;/p&gt;&lt;p&gt;In Ruby its really easy to find a uniq collection by using &lt;code&gt;Array.uniq&lt;/code&gt; or if you have Rails / ActiveRecord and its a database collection you can use &lt;code&gt;.distinct&lt;/code&gt;. &lt;/p&gt;&lt;p&gt;I have found that when I am doing data analysis looking at what has happened over time, events, non-relational data or even relationships between models (when its relational data) - I tend to want to look at duplicate instances of data to compare them and see what is happening.&lt;/p&gt;&lt;p&gt;I keep coming back to this Stackoverflow question, &lt;a href="https://stackoverflow.com/questions/15284182/ruby-how-to-find-non-unique-elements-in-array-and-print-each-with-number-of-occ"&gt;https://stackoverflow.com/questions/15284182/ruby-how-to-find-non-unique-elements-in-array-and-print-each-with-number-of-occ&lt;/a&gt; but I find the solutions a bit too complex for a quick one off script. &lt;/p&gt;&lt;p&gt;My solution is to use a hash, a count and then process out what I'm looking for.&lt;/p&gt;&lt;p&gt;This other Stackoverflow question is a good starting point to figuring out how to create a hash of counts for elements in a collection. &lt;a href="https://stackoverflow.com/questions/5128200/how-to-count-identical-string-elements-in-a-ruby-array"&gt;https://stackoverflow.com/questions/5128200/how-to-count-identical-string-elements-in-a-ruby-array&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Here is my code which can be modified as needed:&lt;/p&gt;&lt;!--kg-card-begin: code--&gt;&lt;pre&gt;&lt;code&gt;counts = Hash.new(0)

##
# counts[element] can be changed to be anything which 
# uniquely identifies the element and is supported by the Hash
# i.e. counts[element.uuid]
#
collection.each { |element| counts[element] += 1 }

# Once you have generated your count of occurances 
# in a collection you can run a sanity check
collection.uniq.size == counts.to_a.size

##
# Getting only non-unique elements
# Structure: { "elementName": 3 }
# with `to_a`: [ [ "elementName", 3 ] ]
counts.to_a.select do |count|
  return true if count.second &amp;gt; 1
end
  &lt;/code&gt;&lt;/pre&gt;&lt;!--kg-card-end: code--&gt;&lt;p&gt;There are issues using this strategy. The main issue is that this process is done in memory. If the dataset you are working with is very large you will have memory and processing issues. I mainly use this for once off checks locally rather than on a production system.&lt;/p&gt;</content:encoded></item><item><title>Moving to Ghost on GitHub Pages</title><description>&lt;p&gt;This blog has had a few migrations to different technologies. In most cases I found a lot of friction to writing new posts which led me to move onto some other technology.&lt;/p&gt;&lt;p&gt;From the beginning I wanted to host this blog on GitHub pages. That is where my homepage is&lt;/p&gt;</description><link>http://localhost:2368/moving-to-ghost-on-github-pages/</link><guid isPermaLink="false">5c83de3c9eb98298f4df03bb</guid><dc:creator>Jason Chalom</dc:creator><pubDate>Sat, 09 Mar 2019 15:39:44 GMT</pubDate><media:content url="http://localhost:2368/content/images/2019/03/racetrack-4.jpg" medium="image"/><content:encoded>&lt;img src="http://localhost:2368/content/images/2019/03/racetrack-4.jpg" alt="Moving to Ghost on GitHub Pages"&gt;&lt;p&gt;This blog has had a few migrations to different technologies. In most cases I found a lot of friction to writing new posts which led me to move onto some other technology.&lt;/p&gt;&lt;p&gt;From the beginning I wanted to host this blog on GitHub pages. That is where my homepage is hosted. I have configured my domain to work with GitHub and CloudFlare and so this led me to try more niche technologies to render my blog - which support GitHub Pages.&lt;/p&gt;&lt;p&gt;I don't really like Jekyll which is my reason for settling on HubPress. But now the project appears dormant and I really have no time to pick up support for an open-source project. I was using a Ghost theme I ported to support HubPress &lt;a href="https://github.com/mityalebedev/The-Shell"&gt;https://github.com/mityalebedev/The-Shell&lt;/a&gt; so I decided to try out Ghost and I really like it. Its simple but provides lots of nice features such as its post editor interface which is very slick. &lt;/p&gt;&lt;p&gt;Ive followed a tutorial from &lt;a href="https://stefanscherer.github.io/setup-ghost-for-github-pages/"&gt;https://stefanscherer.github.io/setup-ghost-for-github-pages/&lt;/a&gt; on how to use Ghost on GitHub pages but there is quite a bit of manual work and it's a pain. For now Im going to try it out and generate static versions of this blog which I'll commit to GitHub. &lt;/p&gt;&lt;p&gt;Most likely in the future I'll move this blog to a hosting solution of some description so that the editing interface can live with the blog and this process can become less tedious and less manual. &lt;/p&gt;</content:encoded></item><item><title>HTTParty, JSON requests and the right Content-Type</title><description>&lt;p&gt;This post is about an issue I discovered whilst trying to debug an issue with a JSON request to a third party service. This request contained a JSON body where one of the fields was an array of strings but when querying the service to see what was sent -&lt;/p&gt;</description><link>http://localhost:2368/httparty-json-requests-and-the-right-content-type/</link><guid isPermaLink="false">5c83d55cb2141f90f1cc1f9e</guid><category>Ruby_On_Rails</category><category>Ruby</category><category>Programming</category><dc:creator>Jason Chalom</dc:creator><pubDate>Sat, 22 Sep 2018 14:03:00 GMT</pubDate><media:content url="http://localhost:2368/content/images/2019/03/aroundtheworld-1.png" medium="image"/><content:encoded>&lt;img src="http://localhost:2368/content/images/2019/03/aroundtheworld-1.png" alt="HTTParty, JSON requests and the right Content-Type"&gt;&lt;p&gt;This post is about an issue I discovered whilst trying to debug an issue with a JSON request to a third party service. This request contained a JSON body where one of the fields was an array of strings but when querying the service to see what was sent - showed that the array was blank. The client used for this request makes use of HTTParty.&lt;/p&gt;&lt;p&gt;Initially I wanted to figure out what my client was sending through to the service. I attempted to use &lt;code&gt;binding.pry&lt;/code&gt; and step through the client to see if something was not functioning correctly.&lt;/p&gt;&lt;p&gt;The body being sent through was something similar to this:&lt;/p&gt;&lt;!--kg-card-begin: code--&gt;&lt;pre&gt;&lt;code&gt;{
  "Param1": "Param1",
  "Array": ["the", "and", "a"]
}&lt;/code&gt;&lt;/pre&gt;&lt;!--kg-card-end: code--&gt;&lt;p&gt;Everything seemed fine to me.&lt;/p&gt;&lt;p&gt;My next step was to backtrack and use Postman to check that the issue was the ruby client and not the third party.&lt;/p&gt;&lt;ol&gt;&lt;li&gt;The body was identical&lt;/li&gt;&lt;li&gt;Here the array was correctly sent to the service and correctly stored&lt;/li&gt;&lt;li&gt;The headers in the Postman request matched those set in the client&lt;/li&gt;&lt;/ol&gt;&lt;h1 id="an-example-of-the-response-i-get"&gt;An example of the response I get&lt;/h1&gt;&lt;!--kg-card-begin: code--&gt;&lt;pre&gt;&lt;code&gt;{
  "ID": 123,
  "Param1": "Param1",
  "Array": []
}&lt;/code&gt;&lt;/pre&gt;&lt;!--kg-card-end: code--&gt;&lt;p&gt;Another dead-end. So I decided to try and log the raw request the client was making. One of the tools used in this project is WebMock to mock out out clients and third party calls.&lt;/p&gt;&lt;p&gt;From &lt;a href="https://tech.degica.com/en/2015/02/26/recording-http-examples/"&gt;https://tech.degica.com/en/2015/02/26/recording-http-examples/&lt;/a&gt; I added this callback:&lt;/p&gt;&lt;!--kg-card-begin: code--&gt;&lt;pre&gt;&lt;code&gt;WebMock.after_request do |req, response|
  request = {
    uri: req.uri.to_s,
    method: req.method.to_s.upcase,
    headers: req.headers,
    body: req.body
  }
  puts JSON.pretty_generate(request)
end&lt;/code&gt;&lt;/pre&gt;&lt;!--kg-card-end: code--&gt;&lt;p&gt;This allowed me to record what my client was actually doing.&lt;/p&gt;&lt;h1 id="the-raw-request"&gt;The raw request&lt;/h1&gt;&lt;!--kg-card-begin: code--&gt;&lt;pre&gt;&lt;code&gt;{
  :uri=&amp;gt;"", :method=&amp;gt;"PUT",
  :headers=&amp;gt;{"X-Apikey"=&amp;gt;"", "Accept"=&amp;gt;"application/json"},
  :body=&amp;gt;"Param1=Param1&amp;amp;Array[]=the&amp;amp;Array[]=and&amp;amp;Array[]=a"
}&lt;/code&gt;&lt;/pre&gt;&lt;!--kg-card-end: code--&gt;&lt;p&gt;Here what was most apparent is that the body seems to have been converted into a paramter string.&lt;/p&gt;&lt;p&gt;&lt;em&gt;(A really good resource on HTTParty and parameter strings is: &lt;a href="https://stackoverflow.com/questions/21856373/sending-array-variables-using-httparty"&gt;https://stackoverflow.com/questions/21856373/sending-array-variables-using-httparty&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;&lt;p&gt;I then wrote a quick and dirty HTTParty call - in the method I was debugging - to the same endpoint but with hardcoded values and a body hash, and it worked :) I then did the exact same call but instead of the hardcoded values I used the same constructors as the previous code (the same header and body methods) and the exact same problem presented itself.&lt;/p&gt;&lt;p&gt;In my ensuing investigation I found that&lt;/p&gt;&lt;!--kg-card-begin: code--&gt;&lt;pre&gt;&lt;code&gt;"Content-Type" =&amp;gt; "application/json"&lt;/code&gt;&lt;/pre&gt;&lt;!--kg-card-end: code--&gt;&lt;p&gt;was missing from the header parameters in the client. Even though the service does not need this header parameter, HTTParty does need it, otherwise it will default to converting the body into a paramter string when HTTParty is called (&lt;code&gt;.get&lt;/code&gt;, &lt;code&gt;.post&lt;/code&gt;, &lt;code&gt;.put&lt;/code&gt; …​) and given a URI and options hash.&lt;/p&gt;&lt;p&gt;If HTTParty is called with the options directly added after the URI it works as expected.&lt;/p&gt;&lt;!--kg-card-begin: code--&gt;&lt;pre&gt;&lt;code&gt;HTTParty.put('https://google.com/', headers: {}, body: {})&lt;/code&gt;&lt;/pre&gt;&lt;!--kg-card-end: code--&gt;&lt;p&gt;But if it is called with an options hash this other behaviour is observed.&lt;/p&gt;&lt;!--kg-card-begin: code--&gt;&lt;pre&gt;&lt;code&gt;options = {headers: {}, body: {}}
HTTParty.put('https://google.com/', options)&lt;/code&gt;&lt;/pre&gt;&lt;!--kg-card-end: code--&gt;&lt;p&gt;&lt;code&gt;format :json&lt;/code&gt; after &lt;code&gt;include HTTParty&lt;/code&gt; also may help.&lt;/p&gt;&lt;h1 id="the-correct-raw-request"&gt;The correct raw request&lt;/h1&gt;&lt;!--kg-card-begin: code--&gt;&lt;pre&gt;&lt;code&gt;{
  :uri=&amp;gt;"", :method=&amp;gt;"PUT",
  :headers=&amp;gt;{"X-Apikey"=&amp;gt;"", "Accept"=&amp;gt;"application/json"},
  :body=&amp;gt;{"Param1": "Param1", "Array": ["the", "and", "a"]}
}&lt;/code&gt;&lt;/pre&gt;&lt;!--kg-card-end: code--&gt;&lt;h1 id="in-conclusion"&gt;In Conclusion&lt;/h1&gt;&lt;p&gt;I came across many people who seemed to be facing the same issue as myself but with no real solutions. The documentation did not seem to help and I found no mention of this behaviour.&lt;/p&gt;&lt;p&gt;By chance I was trying different configuration in desperation and came across the solution.&lt;/p&gt;</content:encoded></item><item><title>Proof of an Optimal Broadcast Algorithm</title><description>&lt;!--kg-card-begin: image--&gt;&lt;figure class="kg-card kg-image-card"&gt;&lt;img src="http://localhost:2368/content/images/2019/03/ring.png" class="kg-image"&gt;&lt;/figure&gt;&lt;!--kg-card-end: image--&gt;&lt;p&gt;Proof of optimality (by induction):&lt;/p&gt;&lt;p&gt;RTP: For n-number of nodes the algorithm has O(n) maximum communication steps.&lt;br&gt;&lt;/p&gt;&lt;p&gt;For n=1: There are 0 communication steps.&lt;br&gt;For n=2: There is 1 communication step.&lt;br&gt;For n=k: There are k communication steps.&lt;br&gt;For n=k+1: There is 1 communication&lt;/p&gt;</description><link>http://localhost:2368/proof-of-an-optimal-broadcast-algorithm/</link><guid isPermaLink="false">5c83d4bcb2141f90f1cc1f8e</guid><category>Computer Science</category><category>Algorithms</category><dc:creator>Jason Chalom</dc:creator><pubDate>Sat, 27 May 2017 13:58:00 GMT</pubDate><content:encoded>&lt;!--kg-card-begin: image--&gt;&lt;figure class="kg-card kg-image-card"&gt;&lt;img src="http://localhost:2368/content/images/2019/03/ring.png" class="kg-image"&gt;&lt;/figure&gt;&lt;!--kg-card-end: image--&gt;&lt;p&gt;Proof of optimality (by induction):&lt;/p&gt;&lt;p&gt;RTP: For n-number of nodes the algorithm has O(n) maximum communication steps.&lt;br&gt;&lt;/p&gt;&lt;p&gt;For n=1: There are 0 communication steps.&lt;br&gt;For n=2: There is 1 communication step.&lt;br&gt;For n=k: There are k communication steps.&lt;br&gt;For n=k+1: There is 1 communication step.&lt;/p&gt;&lt;p&gt;∴ The number of communication steps can never exceed the number of nodes in this configuration, i.e. This is the optimal broadcast algorithm for this network design. The smallest number of communication steps is 1 (between more than one node) and the largest possible amount of steps is k.&lt;/p&gt;&lt;p&gt;This is a simple example of an algorithmic proof of optimality. For parallel systems and more complex network structure the proofs can become more involved.&lt;/p&gt;</content:encoded></item></channel></rss>